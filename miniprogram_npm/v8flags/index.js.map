{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// this entire module is depressing. i should have spent my time learning\n// how to patch v8 so that these options would just be available on the\n// process object.\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst execFile = require('child_process').execFile;\nconst env = process.env;\nconst user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME || '';\nconst exclusions = ['--help'];\n\nconst configfile = '.v8flags.'+process.versions.v8+'.'+crypto.createHash('md5').update(user).digest('hex')+'.json';\n\nconst failureMessage = [\n  'Unable to cache a config file for v8flags to a your home directory',\n  'or a temporary folder. To fix this problem, please correct your',\n  'environment by setting HOME=/path/to/home or TEMP=/path/to/temp.',\n  'NOTE: the user running this must be able to access provided path.',\n  'If all else fails, please open an issue here:',\n  'http://github.com/tkellen/js-v8flags'\n].join('\\n');\n\nfunction fail (err) {\n  err.message += '\\n\\n' + failureMessage;\n  return err;\n}\n\nfunction openConfig (cb) {\n  var userHome = require('user-home');\n  if (!userHome) {\n    return tryOpenConfig(path.join(os.tmpdir(), configfile), cb);\n  }\n\n  tryOpenConfig(path.join(userHome, configfile), function (err, fd) {\n    if (err) return tryOpenConfig(path.join(os.tmpdir(), configfile), cb);\n    return cb(null, fd);\n  });\n}\n\nfunction tryOpenConfig (configpath, cb) {\n  try {\n    // if the config file is valid, it should be json and therefore\n    // node should be able to require it directly. if this doesn't\n    // throw, we're done!\n    var content = require(configpath);\n    process.nextTick(function () {\n      cb(null, content);\n    });\n  } catch (e) {\n    // if requiring the config file failed, maybe it doesn't exist, or\n    // perhaps it has become corrupted. instead of calling back with the\n    // content of the file, call back with a file descriptor that we can\n    // write the cached data to\n    fs.open(configpath, 'w+', function (err, fd) {\n      if (err) {\n        return cb(err);\n      }\n      return cb(null, fd);\n    });\n  }\n}\n\n// i can't wait for the day this whole module is obsolete because these\n// options are available on the process object. this executes node with\n// `--v8-options` and parses the result, returning an array of command\n// line flags.\nfunction getFlags (cb) {\n  execFile(process.execPath, ['--v8-options'], function (execErr, result) {\n    if (execErr) {\n      return cb(execErr);\n    }\n    var flags = result.match(/\\s\\s--(\\w+)/gm).map(function (match) {\n      return match.substring(2);\n    }).filter(function (name) {\n      return exclusions.indexOf(name) === -1;\n    });\n    return cb(null, flags);\n  });\n}\n\n// write some json to a file descriptor. if this fails, call back\n// with both the error and the data that was meant to be written.\nfunction writeConfig (fd, flags, cb) {\n  var buf = new Buffer(JSON.stringify(flags));\n  return fs.write(fd, buf, 0, buf.length, 0 , function (writeErr) {\n    fs.close(fd, function (closeErr) {\n      var err = writeErr || closeErr;\n      if (err) {\n        return cb(fail(err), flags);\n      }\n      return cb(null, flags);\n    });\n  });\n}\n\nmodule.exports = function (cb) {\n  // bail early if this is not node\n  var isElectron = process.versions && process.versions.electron;\n  if (isElectron) {\n    return process.nextTick(function () {\n      cb(null, []);\n    });\n  }\n\n  // attempt to open/read cache file\n  openConfig(function (openErr, result) {\n    if (!openErr && typeof result !== 'number') {\n      return cb(null, result);\n    }\n    // if the result is not an array, we need to go fetch\n    // the flags by invoking node with `--v8-options`\n    getFlags(function (flagsErr, flags) {\n      // if there was an error fetching the flags, bail immediately\n      if (flagsErr) {\n        return cb(flagsErr);\n      }\n      // if there was a problem opening the config file for writing\n      // throw an error but include the flags anyway so that users\n      // can continue to execute (at the expense of having to fetch\n      // flags on every run until they fix the underyling problem).\n      if (openErr) {\n        return cb(fail(openErr), flags);\n      }\n      // write the config file to disk so subsequent runs can read\n      // flags out of a cache file.\n      return writeConfig(result, flags, cb);\n    });\n  });\n};\n\nmodule.exports.configfile = configfile;\n"]}